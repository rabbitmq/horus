<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Module horus</title>
<link rel="stylesheet" type="text/css" href="edoc-extensions.css" title="EDoc">
<link rel="icon" href="horus-favicon.svg" type="image/svg+xml">
</head>
<body class="markdown-body language-erlang"><script src="prism.js"></script>
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module horus</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>Library to create standalone modules from anonymous functions.


<h2><a name="description">Description</a></h2><p>Library to create standalone modules from anonymous functions.</p>
 
  <p>This module is responsible for extracting the code of an anonymous function.  
The goal is to be able to store the extracted function and execute it later,  
regardless of the availability of the initial Erlang module which declared  
it.</p>
 
  <p>This module also provides a way for the caller to indicate forbidden  
operations or function calls.</p>
 
  <p>This module works on assembly code to perform all checks and prepare the
  storable copy of a function. It uses <a docgen-rel="seemfa" docgen-href="beam_disasm#file/1" href="beam_disasm.html#file-1"><code>beam_disasm:file/1</code></a> from the
  <code>compiler</code> application to extract the assembly code. After the assembly  
code was extracted and modified, the compiler is used again to compile the  
code back to an executable module.</p>
 
  <p>If the anonymous function calls other functions, either in the same module  
or in another one, the code of the called functions is extracted and copied  
as well. This is to make sure the result is completely standalone.</p>
 
  <p>Calls to functions from standard Erlang APIs or Horus itself are left as  
external calls (i.e. their code is not copied). To avoid any copies of  
other modules, it is possible to specify a list of modules which should not  
be copied. In this case, calls to functions in those modules are left  
unmodified.</p>
 
  <p>Once the code was extracted and verified, a new module is generated as an
  "assembly form", ready to be compiled again to an executable module. The
  generated module has a single <code>run/N</code> exported function. This function  
contains the code of the extracted anonymous function.</p>
 
  <p>Because this process works on the assembly code, it means that if the  
initial module hosting the anonymous function was compiled with Erlang  
version N, it will probably not compile or run on older versions of Erlang.  
The reason is that a newer compiler may use instructions which are unknown  
to older runtimes.</p>
 
  <p>There is a special treatment for anonymous functions evaluated by
  <code>erl_eval</code> (e.g. in the Erlang shell). "erl_eval functions" are lambdas
  parsed from text and are evaluated using <code>erl_eval</code>.</p>
 
  <p>This kind of lambdas becomes a local function in the <code>erl_eval</code> module.</p>
 
  Their assembly code isn't available in the <code>erl_eval</code> module. However, the
  abstract code (i.e. after parsing but before compilation) is available in
  the <code>env</code>. We compile that abstract code and extract the assembly from that
  compiled beam.
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-asm">asm()</a></h3>
<p><code>asm() = {module(), [{atom(), arity()}], [], [#function{name = atom(), arity = byte(), entry = <a href="/home/runner/work/horus/stdlib/doc/beam_lib.html#type-label">beam_lib:label()</a>, code = [<a href="#type-beam_instr">beam_instr()</a>]}], <a href="#type-label">label()</a>}</code></p>
<p><p>  The assembly form passed to the compiler.</p>
 
  It should be exported by the compiler application ideally.</p>

<h3 class="typedecl"><a name="type-beam_instr">beam_instr()</a></h3>
<p><code>beam_instr() = atom() | tuple()</code></p>
<p>  A beam assembly instruction.</p>

<h3 class="typedecl"><a name="type-debug_info">debug_info()</a></h3>
<p><code>debug_info() = #{fun_info := <a href="#type-fun_info">fun_info()</a>, checksums := #{module() =&gt; binary()}, asm := <a href="#type-asm">asm()</a>}</code></p>
<p><p>  Optional details added to the standalone function record.</p>
 
  They are only added if the <code>debug_info</code> <a docgen-rel="seetype" docgen-href="#options/0" href="#type-options"><code>options()</code></a> is set to true.</p>

<h3 class="typedecl"><a name="type-ensure_instruction_is_permitted_fun">ensure_instruction_is_permitted_fun()</a></h3>
<p><code>ensure_instruction_is_permitted_fun() = fun((Instruction::<a href="#type-beam_instr">beam_instr()</a>) -&gt; ok)</code></p>
<p><p>  Function which evaluates the given instruction and returns <code>ok</code> if it is  
permitted, throws an exception otherwise.</p>
 
  <p>Example:</p>
 
  <pre><code>Fun = fun
          ({jump, _})    -&gt; ok;
          ({move, _, _}) -&gt; ok;
          ({trim, _, _}) -&gt; ok;
          (Unknown)      -&gt; throw({unknown_instruction, Unknown})
      end.</code></pre></p>

<h3 class="typedecl"><a name="type-fun_info">fun_info()</a></h3>
<p><code>fun_info() = #{arity =&gt; arity(), env =&gt; any(), index =&gt; any(), name =&gt; atom(), module =&gt; module(), new_index =&gt; any(), new_uniq =&gt; any(), pid =&gt; any(), type =&gt; local | external, uniq =&gt; any()}</code></p>
<p>  Information returned by <a docgen-rel="seemfa" docgen-href="erlang#fun_info/1" href="erlang.html#fun_info-1"><code>erlang:fun_info/1</code></a>.</p>

<h3 class="typedecl"><a name="type-fun_name_mapping">fun_name_mapping()</a></h3>
<p><code>fun_name_mapping() = #{{atom(), arity()} =&gt; mfa()}</code></p>
<p><p>  Extracted function name to its original MFA mapping.</p>
 
  This is used to reconstruct a meaningful stacktrace in case of an
  exception.</p>

<h3 class="typedecl"><a name="type-horus_fun">horus_fun()</a></h3>
<p><code>horus_fun() = #horus_fun{module = module(), beam = binary(), arity = arity(), literal_funs = [<a href="/home/runner/work/horus/horus/doc/horus.html#type-horus_fun">horus:horus_fun()</a>], fun_name_mapping = <a href="/home/runner/work/horus/horus/doc/horus.html#type-fun_name_mapping">horus:fun_name_mapping()</a>, env = list(), debug_info = <a href="/home/runner/work/horus/horus/doc/horus.html#type-debug_info">horus:debug_info()</a> | undefined} | function()</code></p>
<p><p>  The result of an extraction, as returned by <a docgen-rel="seemfa" docgen-href="#to_standalone_fun/2" href="#to_standalone_fun-2"><code>to_standalone_fun/2</code></a>.</p>
 
  It can be stored, passed between processes and Erlang nodes. To execute the
  extracted function, simply call <a docgen-rel="seemfa" docgen-href="#exec/2" href="#exec-2"><code>exec/2</code></a> which works like <a docgen-rel="seemfa" docgen-href="erlang#apply/2" href="erlang.html#apply-2"><code>erlang:apply/2</code></a>.</p>

<h3 class="typedecl"><a name="type-is_standalone_fun_still_needed_fun">is_standalone_fun_still_needed_fun()</a></h3>
<p><code>is_standalone_fun_still_needed_fun() = fun((#{calls := #{Call::mfa() =&gt; true}, errors := [Error::any()]}) -&gt; IsNeeded::boolean())</code></p>
<p><p>  Function which evaluates if the extracted function is still relevant in the  
end. It returns true if it is, false otherwise.</p>
 
  It takes a map with the following members:
  <ul>
  <li><code>calls</code>, a map of all the calls performed by the extracted code (only
  the key is useful, the value is always true).</li>
  <li><code>errors</code>, a list of errors collected during the extraction.</li>
  </ul></p>

<h3 class="typedecl"><a name="type-label">label()</a></h3>
<p><code>label() = pos_integer()</code></p>
<p><p>  a beam assembly label.</p>
 
  Other assembly instructions can jump to this label.</p>

<h3 class="typedecl"><a name="type-options">options()</a></h3>
<p><code>options() = #{ensure_instruction_is_permitted =&gt; <a href="#type-ensure_instruction_is_permitted_fun">ensure_instruction_is_permitted_fun()</a>, should_process_function =&gt; <a href="#type-should_process_function_fun">should_process_function_fun()</a>, is_standalone_fun_still_needed =&gt; <a href="#type-is_standalone_fun_still_needed_fun">is_standalone_fun_still_needed_fun()</a>, add_module_info =&gt; boolean(), debug_info =&gt; boolean()}</code></p>
<p><p>  Options to tune the extraction of an anonymous function.</p>
 
  <ul>
  <li><code>ensure_instruction_is_permitted</code>: a function which evaluates if an
  instruction is permitted or not.</li>
  <li><code>should_process_function</code>: a function which returns if a called module
  and function should be extracted as well or left alone.</li>
  <li><code>is_standalone_fun_still_needed</code>: a function which returns if, after
  the extraction is finished, the extracted function is still needed in
  comparison to keeping the initial anonymous function.</li>
  <li><code>add_module_info</code>: a boolean to indicate if the <code>module_info/0</code> and
  <code>module_info/1</code> functions should be added to the generated module. There
  are used by tracing and debugging tools in Erlang, but they take some space
  (about 140 bytes). Default is true.</li>
  <li><code>debug_info</code>: a boolean to indicate if details should be added to the
  <code>#horus_fun.debug_info</code> field. See <a docgen-rel="seetype" docgen-href="#debug_info/0" href="#type-debug_info"><code>debug_info()</code></a>.</li>
  </ul></p>

<h3 class="typedecl"><a name="type-should_process_function_fun">should_process_function_fun()</a></h3>
<p><code>should_process_function_fun() = fun((Module::module(), Function::atom(), Arity::arity(), FromModule::module()) -&gt; ShouldProcess::boolean())</code></p>
<p><p>  Function which returns true if a called function should be extracted and  
followed, false otherwise.</p>
 
  <p><code>Module</code>, <code>Function</code> and <code>Arity</code> qualify the function being called.</p>
 
  <p><code>FromModule</code> indicates the module performing the call. This is useful to
  distinguish local calls (<code>FromModule</code> == <code>Module</code>) from remote calls.</p>
 
  <p>Example:</p>
 
  <pre><code>Fun = fun(Module, Name, Arity, FromModule) -&gt;
              Module =:= FromModule orelse
              erlang:function_exported(Module, Name, Arity)
      end.</code></pre></p>

<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#to_standalone_fun-1">to_standalone_fun/1</a></td><td>Extracts the given anonymous function.</td></tr>
<tr><td valign="top"><a href="#to_standalone_fun-2">to_standalone_fun/2</a></td><td>Extracts the given anonymous function.</td></tr>
<tr><td valign="top"><a href="#exec-2">exec/2</a></td><td>Executes a previously extracted anonymous function.</td></tr>
<tr><td valign="top"><a href="#forget_overridden_object_code-1">forget_overridden_object_code/1</a></td><td></td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="to_standalone_fun-1">to_standalone_fun/1</a></h3>
<div class="spec">
<p><code>to_standalone_fun(Fun) -&gt; StandaloneFun</code>
<ul class="definitions"><li><code>Fun = function()</code></li><li><code>StandaloneFun = <a href="#type-horus_fun">horus_fun()</a></code></li></ul></p>
<p><code>Fun</code>: the anonymous function to extract
 <br>
</p>
<p>returns: a standalone function record or the same anonymous function if no
  extraction was needed.</p>
</div><p><p>Extracts the given anonymous function.</p>
 
  This is the same as:
  <pre><code>horus:to_standalone_fun(Fun, #{}).</code></pre>
 </p>

<h3 class="function"><a name="to_standalone_fun-2">to_standalone_fun/2</a></h3>
<div class="spec">
<p><code>to_standalone_fun(Fun, Options) -&gt; StandaloneFun</code>
<ul class="definitions"><li><code>Fun = function()</code></li><li><code>Options = <a href="#type-options">options()</a></code></li><li><code>StandaloneFun = <a href="#type-horus_fun">horus_fun()</a></code></li></ul></p>
<p><code>Fun</code>: the anonymous function to extract<br>
<code>Options</code>: a map of options
 <br>
</p>
<p>returns: a standalone function record or the same anonymous function if no
  extraction was needed.</p>
</div><p><p>Extracts the given anonymous function.</p>
 
  Example of successful extraction:
  <pre><code>Fun = fun(Term) -&gt;
          io:format(standard_error, "~p~n", [Term])
      end,
StandaloneFun = horus:to_standalone_fun(Fun),
 
horus:exec(StandaloneFun, [calendar:local_time()]).</code></pre>
 
  Example of an error, trying to export a non-existing function:
  <pre><code>horus:to_standalone_fun(fun not_a_module:not_a_function/0).
 
%% ** exception throw: {horus, call_to_unexported_function,
%%                             #{mfa =&gt; {not_a_module, not_a_function, 0}}}</code></pre>
 </p>

<h3 class="function"><a name="exec-2">exec/2</a></h3>
<div class="spec">
<p><code>exec(StandaloneFun, Args) -&gt; Ret</code>
<ul class="definitions"><li><code>StandaloneFun = <a href="#type-horus_fun">horus_fun()</a></code></li><li><code>Args = [any()]</code></li><li><code>Ret = any()</code></li></ul></p>
<p><code>StandaloneFun</code>: the extracted function as returned by <a docgen-rel="seemfa" docgen-href="#to_standalone_fun/2" href="#to_standalone_fun-2"><code>to_standalone_fun/2</code></a>.<br>
<code>Args</code>: the list of arguments to pass to the extracted function.
 <br>
</p>
<p>returns: the return value of the extracted function.</p>
</div><p><p>Executes a previously extracted anonymous function.</p>
 
  <p>This is the equivalent of <a docgen-rel="seemfa" docgen-href="erlang#apply/2" href="erlang.html#apply-2"><code>erlang:apply/2</code></a> but it supports extracted  
anonymous functions.</p>
 
  <p>The list of <code>Args</code> must match the arity of the anonymous function.</p>
 
  Example:
  <pre><code>Fun = fun(Term) -&gt;
          io:format(standard_error, "~p~n", [Term])
      end,
StandaloneFun = horus:to_standalone_fun(Fun),
 
horus:exec(StandaloneFun, [calendar:local_time()]).</code></pre>
 </p>

<h3 class="function"><a name="forget_overridden_object_code-1">forget_overridden_object_code/1</a></h3>
<div class="spec">
<p><code>forget_overridden_object_code(Module) -&gt; any()</code></p>
<p></p>
</div>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc</i></p>
</body>
</html>
